$date
	Sat Oct 18 11:27:37 2014
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module comp2 $end
$var wire 32 ! a [31:0] $end
$var wire 32 " b [31:0] $end
$var reg 1 # isEq $end
$upscope $end
$scope module muj_obvod $end
$var wire 1 $ a $end
$var wire 1 % b $end
$var wire 1 & c $end
$var wire 1 ' d $end
$var wire 1 ( e $end
$upscope $end
$scope module multAx4 $end
$var wire 32 ) a [31:0] $end
$var reg 32 * e [31:0] $end
$var reg 1 + isZero $end
$upscope $end
$scope module mux2 $end
$var wire 32 , a [31:0] $end
$var wire 32 - b [31:0] $end
$var wire 1 . x $end
$var reg 32 / e [31:0] $end
$upscope $end
$scope module mux3 $end
$var wire 32 0 a [31:0] $end
$var wire 32 1 b [31:0] $end
$var wire 32 2 c [31:0] $end
$var wire 2 3 x [1:0] $end
$var reg 32 4 e [31:0] $end
$upscope $end
$scope module muxCv $end
$var wire 1 5 a $end
$var wire 1 6 b $end
$var wire 1 7 c $end
$var wire 1 8 d $end
$var reg 1 9 e $end
$upscope $end
$scope module register32 $end
$var wire 32 : a [31:0] $end
$var wire 1 ; clk $end
$var wire 1 < en $end
$var wire 1 = rs $end
$var reg 32 > e [31:0] $end
$upscope $end
$scope module signExt16t32 $end
$var wire 16 ? a [15:0] $end
$var reg 32 @ e [31:0] $end
$upscope $end
$scope module sum32 $end
$var wire 32 A a [31:0] $end
$var wire 32 B b [31:0] $end
$var reg 32 C e [31:0] $end
$var reg 1 D isZero $end
$var reg 1 E overflow $end
$upscope $end
$scope module test $end
$var reg 1 F clk $end
$var reg 32 G d [31:0] $end
$var reg 1 H en $end
$var reg 5 I i1 [4:0] $end
$var reg 5 J i2 [4:0] $end
$var reg 5 K i3 [4:0] $end
$var reg 1 L rs $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
0L
b11 K
b1 J
b0 I
1H
b11111111111111111111111111111111 G
0F
0E
0D
bx C
bz B
bz A
bz0000000000000000zzzzzzzzzzzzzzz @
bz ?
bx >
z=
z<
z;
bz :
x9
z8
z7
z6
z5
bz 4
bz 3
bz 2
bz 1
bz 0
bz /
z.
bz -
bz ,
0+
bx *
bz )
x(
x'
z&
z%
z$
0#
bz "
bz !
$end
#20
1F
#40
0F
#60
1F
#80
0F
#100
1F
#120
0F
#140
1F
#160
0F
#180
1F
#200
0F
#220
1F
#240
0F
#260
1F
#280
0F
#300
1F
#320
0F
